[{"title":"我的效率软件","date":"2020-09-16T02:53:44.000Z","path":"2020/09/16/我的效率软件/","text":"Windows OSWox快速搜索，类似mac的 spotlight Everything文件搜索，配合 Wow 使用 QuickLook空格键后，快速预览工具 Riot图片压缩 Peacock Color Picker屏幕拾色软件 Snipaste屏幕截图，亦拾色 ScreenToGif录制屏幕生成gif iConvert Icons给app生成ico图片 Fiddler抓包软件，可修改请求与响应信息 Proxifier指定应用程序走代理","tags":[]},{"title":"nodejs 相关","date":"2019-12-09T00:57:48.000Z","path":"2019/12/09/nodejs-相关/","text":"nvm Node Version ManagerNode 版本管理器，在开发环境下，方便让一台电脑安装不同版本的node 建议全局安装的NPM的功能包nrm NPM registry managerNPM 包源管理器，默认的https://registry.npmjs.org/包源地址，国内常常响应缓慢，可以通过nrm 切换至 taobao源，快速方便 live-server 将当前目录，设置为静态服务；之后可快速的通过本机ip或localhost的http形式，访问目录 12345678/* * 默认情况下，post请求时，是不会有返回； * 如须支持，请在安装 live-server的node_modules目录下 * 找到 live-server 目录并进入，打开 index.js * 修改第 42 行，如下： */if (req.method !== &quot;GET&quot; &amp;&amp; req.method !== &quot;POST&quot; &amp;&amp; req.method !== &quot;HEAD&quot;) return next(); rimraf 删除指定文件或目录；相比系统自带的delete，在删除目录层级很深的情形下，rimraf速度提升不少","tags":[]},{"title":"Vue与Electron成长记","date":"2019-11-28T08:33:10.000Z","path":"2019/11/28/Vue与Electron成长记/","text":"vue项目完成后，如果想打包为应用程序，可以使用Electron，从零开始，上手步骤如下： 安装 Vue CLI 通过 vue ui 新建项目 项目安装 vue-cli-plugin-electron-builder 插件 进入 vue ui 仪表板 进入 任务 菜单 选择 electron:build 设置 变量 后，点击 运行 即可尝鲜打包后的桌面应用","tags":[]},{"title":"推荐安装Chrome扩展程序","date":"2019-11-26T09:28:50.000Z","path":"2019/11/26/推荐安装Chrome扩展程序/","text":"Window Resizer 快速改变chrome窗口大小，或者视窗大小。 简悦 - SimpRead 类似 Safari 的阅读模式。 捕捉网页截图 - FireShot 捕捉网页截图，编辑并将它们保存为PDF，JPEG，GIF，PNG或BMP。 沙拉查词-聚合词典划词翻译 划词翻译扩展。 AdBlock 广告拦截工具 在YouTube、Facebook、Twitch和其他你喜爱的网站上拦截广告和弹窗。 广告终结者 清除网页上的所有广告：浮动广告，购物广告，恶意弹窗，跟踪代码。 WEB前端助手(FeHelper) 包含多个独立小应用，比如：Json工具、代码美化、代码压缩、二维码、Postman、markdown、网页油猴、便签笔记、信息加密与解密、随机密码生成、Crontab等等。 User-Agent Switcher for Chrome 模拟修改 User-Agent。 Octotree Github 目录层级以树形式展示，便捷查看。 ColorZilla 网页拾色工具。","tags":[]},{"title":"Hello World","date":"2019-11-13T01:39:58.505Z","path":"2019/11/13/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"JS-Date-总结","date":"2018-08-01T02:32:08.000Z","path":"2018/08/01/JS-Date-总结/","text":"在javascript中对日期的操作还是很多的，比如给日期控件设定个默认值，在vue中根据Date值返回对应毫秒数，使用场景还是很多的，那么个人常用的场景有如下： 给日期控件设定默认值时，需要指定默认的日期时间，例如设定默认日期时间为 2008-10-08 12:12:12 1234let defaultDate = new Date('2008-10-08 12:12:12');let defaultDateMS = Date.parse(defaultDate);console.log(defaultDate);//Wed Oct 08 2008 12:12:12 GMT+0800console.log(defaultDateMS);//1223439132000 默认值为当前的前一天的早上六点 1234let defaultDate = new Date(new Date().setHours(6,0,0));defaultDate.setDate(defaultDate.getDate()-1);console.log(defaultDate);//Tue Jul 31 2018 06:00:00 GMT+0800console.log(Date.parse(defaultDate));//1532988000000 默认值为上月的第一天或最后一天 1234567891011let lastMonthFirstDay = new Date(new Date().setHours(0,0,0));lastMonthFirstDay.setMonth(lastMonthFirstDay.getMonth()-1);lastMonthFirstDay.setDate(1);console.log(lastMonthFirstDay);//Sun Jul 01 2018 00:00:00 GMT+0800console.log(Date.parse(lastMonthFirstDay));//1530374400000let lastMonthLastDay = new Date(new Date().setHours(0,0,0));lastMonthLastDay.setDate(1);lastMonthLastDay.setDate(lastMonthLastDay.getDate()-1);console.log(lastMonthLastDay);//Tue Jul 31 2018 00:00:00 GMT+0800console.log(Date.parse(lastMonthLastDay));//1532966400000","tags":[{"name":"javascript","slug":"javascript","permalink":"https://tangme.github.io/tags/javascript/"}]},{"title":"JS-网传问题回顾","date":"2018-06-07T03:41:31.000Z","path":"2018/06/07/JS-网传问题回顾/","text":"问题 使用typeof bar ===“object”来确定bar是否是一个对象时有什么潜在的缺陷？这个陷阱如何避免？ let a = b = c = ‘value’; 方式声明赋值时，有没有潜在风险？ 答案使用 typeof bar === “object” 来确定bar是否是一个对象时有什么潜在的缺陷？这个陷阱如何避免？之所以使用 typeof bar === object&quot; ，是因为大多数情况下我们想检测一个变量是否为一个对象。但是当待检测的变量为null ，或者赋值方式为以下几种方式时，如果没有深入了解数据类型的话，则会有挠头的姿态出现了： 123456789101112let a = new Date();let b = new Number(110);let c = new String('hello world');let d = new Boolean(true);let e = 'just string';console.log(typeof null);console.log(typeof a,a,a.toString());console.log(typeof b,b,b.toString());console.log(typeof c,c,c.toString());console.log(typeof d,d,d.toString());console.log(typeof e); 这里当值为 null，或者以 new关键字形式赋值后，输出的值均为 object。这里不深究数据类型，但如果我们想确切的检测一个变量的类型时，可以参考 jQuery的实现方式： 12345678910111213141516171819202122232425262728/*此处为非jQuery，但参考jQuery而来的实现方式代码块*/const class2type = &#123;&#125;;\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \").map(function(item)&#123; class2type[\"[object \"+item+\"]\"] = item.toLowerCase();&#125;);function type( obj ) &#123; if ( obj == null ) &#123; return obj + \"\"; &#125; // Support: Android &lt;=2.3 only (functionish RegExp) return typeof obj === \"object\" || typeof obj === \"function\" ? class2type[ toString.call( obj ) ] || \"object\" : typeof obj;&#125;let a = new Date();let b = new Number(110);let c = new String('hello world');let d = new Boolean(true);let e = 'just string';console.log(type(null));console.log(type(a));console.log(type(b));console.log(type(c));console.log(type(d));console.log(type('just string')); let a = b = c = ‘value’; 方式声明赋值时，有没有潜在风险？1234567(function()&#123; var a = b = c = 3;&#125;)(); console.log(\"a defined? \" + (typeof a !== 'undefined'),typeof a);console.log(\"b defined? \" + (typeof b !== 'undefined'),typeof b);console.log(\"c defined? \" + (typeof c !== 'undefined'),typeof c); 会打印出什么内容呢？想一想。 打印的结果是：a 为 undefined，b 和 c 为赋值后的数值。为啥呢？因为我们仅对 变量a 进行了 var 关键字变量声明，而 b 和 c 在未指定变量声明方式时，默认成为了全局变量，在根据赋值从右至左的顺序，c 和 b 相继赋值为 3。 好了，以上情况仅在非严格模式下出现，在严格模式下，因为 b 和 c 未指定变量声明关键字，会提示 ReferenceError: b c is not defined。 再来，那在非严格模式下，有没有啥潜在隐患呢？思考下面的代码块： 1234567891011121314var b = 1,c = 2;(function()&#123; var a, b, c = 3; a = b = c; console.log('a + b + c = ' + (a + b + c));&#125;)();console.log('b + c = ' + (b + c));/*----------------------------------*/var bb = 1,cc = 2;(function()&#123; var aa = bb = cc = 3; console.log('aa + bb + cc = '+ (aa + bb + cc));&#125;)();console.log('bb + cc = '+ (bb + cc)); 可以注意到，两者的区别就在立即执行函数内部 变量的声明和赋值方式，也因此最后输出的值产生了差异。在代码块1中，立即执行函数中，相继声明了 b , c 两个局部变量，之后的赋值也正是赋值给此两个局部变量；而代码块2中，则是对全局变量 bb ，cc赋值，也就造成最终二者不同的输出值了。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://tangme.github.io/tags/javascript/"}]},{"title":"VUE中的-methods-computed-watch","date":"2018-06-04T01:53:10.000Z","path":"2018/06/04/VUE中的-methods-computed-watch/","text":"原文地址 methods,computed和watch的易用性与相互之间明确使用场景的定位，是我喜欢使用Vue的原因之一。如不了解以上三者，那么很难发挥Vue的所有潜在功能。在我看来，大多数对此(Vue)框架有困惑的人，同时对以上三者的区别也有着疑惑，那么现在让我们来探究下。 如果你只须一个结论，或者没有时间通读全文，以下则是总结： methods: 如同词语自身描述的一样。它们是处理对象的方法，通常来说是Vue实例本身，或者是Vue组件。 computed: 这些属性第一眼看起来，像是被当作方法使用，但实则不然。在Vue中，我们使用 data 来跟踪特定属性的变化。computed 属性允许我们定义一个属性以 data 同样的方式来使用，但不同是，拥有一套自定的逻辑基于已有的缓存依赖项上。你可以把计算属性认为是 data被逻辑处理后的形式。 watch: 其能允许你一览反应系统。我们提供了些钩子来观察存储在 Vue 中的任何属性。如果我们想在每时每刻一有变化时就增加一些功能，或者相应特定的变化，我们可以监听一个属性，然后，赋予些逻辑。这就是说，监听器必须匹配我们所观察的属性。 如果以上的措辞使你困惑，别着急。接下来我们将深入讲解，以希望能解决你的所有疑惑。如果你已对 JavaScript 很熟悉，methods对你应毫无压力，(当然除了一两个值得留心的小点)。那么可以直接游览 computed 和 watch 章节。 MethodsMethods 应该是我们在Vue中使用的最多了东西了。They’re aptly named as, in essence, we’re hanging a function off of an object。在给事件响应指令，亦或重构一个函数进行复用的情形下，方法都尤为实用。例如，你能在一个方法中调用另一个方法。也能在生命周期钩子事件中调用方法。使用很是灵巧。以下为一个示例演示： 点击查看在线DEMO 123456&lt;!-- html code --&gt;&lt;code class=\"language-css\"&gt;&lt;div id=\"app\"&gt; &lt;button @click=\"tryme\"&gt;Try Me&lt;/button&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;/div&gt; 1234567891011121314/* javascript code*/new Vue(&#123; el: '#app', data() &#123; return &#123; message: null &#125; &#125;, methods: &#123; tryme() &#123; this.message = Date() &#125; &#125;&#125;) 我们也能直接在事件中中执行逻辑指令，如 &lt;button @click=&quot;message = Date()&quot;&gt;Try Me&lt;/button&gt;，在这个小例子中也能顺利执行。但是呢，随着我们开发应用复杂度的增长，更常见的作法是如我们上面例子所展示的，把业务代码抽取出，以获得更好的代码可读性与可维护性。在Vue中使用指令时，也有一些限制，例如：表达式是允许的，但是声明则不行。 你可能注意到了，我们在Vue实例或组件中调用此方法，并且在此方法中可以访问所有的data数据，此例中为,this.message。在指令中不必非得像调用函数那样调用方法。例如，@click=”methodName()” 可以引用为@click=”methodName”，当然如需传递参数时，则是@click=”methodName(param)”。 使用指令调用方法很赞的另一个原因是，我们能够使用一些修饰符。下例中一个很有用的修饰符为.prevent，此修饰符将阻止默认提交事件后刷新页面的情形，例子如下：1&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt; 更多信息，请移步到这 Computed计算属性在控制处理已有数据上是非常有用的。当你需要对一个大量数据进行排序又不想每次获取计算后的返回值时，可以了解下计算属性。 以下为一些适当使用计算属性的条件，但不局限与此： 在用户输入信息后，需要对已有的大量数据更新，如过滤显示符合输入内容的信息 从 Vuex 状态管理器中采集信息。 表单验证 根据用户所想看的可视化数据信息展示 对于理解Vue，计算属性是很重要的一部分。计算属性的计算值会根据它们所依赖的数据进行缓存，并只有当符合特定条件时更新。当合理使用计算属性时，其是非常高效和有用的。此外，已经有很多健壮的库和函数提供给我们来处理业务逻辑部分，以降低编程时的代码量。 计算属性并不像方法那样来的使用，尽管它两看起来很相似。计算属性是：你在一个函数中编写逻辑代码并返回符合逻辑的值，但是 此方法的函数名 将会变成一个属性，就像你在应用使用 data里的属性一样。 如果我们想在一个大量的英雄名称列表中，通过输入关键字来过滤内容，我们可以采取下面的方式，并且通过这个简单的例子让你对计算属性有个初步的概念。首先，我们的使用存储在 data 中的 names 属性，将列表内容输出在模板中： 1234567891011121314new Vue(&#123; el: '#app', data() &#123; return &#123; names: [ 'Evan You', 'John Lindquist', 'Jen Looper', 'Miriam Suzanne', ... ] &#125; &#125;&#125;) 12345678&lt;div id=\"app\"&gt; &lt;h1&gt;Heroes&lt;/h1&gt; &lt;ul&gt; &lt;li v-for=\"name in names\"&gt; &#123;&#123; name &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 现在，给这些名称添加一些过滤代码。首先，给文本输入框绑定v-mode，且初始为空字符串值，当然最终我们会使用文本输入框中的值去匹配和过滤后我们的名称列表。给输入文本框绑定的属性值为findName，其与data中的值保持引用关联。 12&lt;label for=\"filtername\"&gt;Find your hero:&lt;/label&gt;&lt;input v-model=\"findName\" id=\"filtername\" type=\"text\" /&gt; 12345678910data() &#123; return &#123; findName: '', names: [ 'Evan You', 'John Lindquist', ... ] &#125;&#125; 接下来，我们创建一个计算属性，其会根据用户在文本输入框中键入的内容，来过滤掉只符合findName属性值相关的名称内容。这里可以看到我使用了正则表达式来弱化了大小写的敏感度，因为作为一个用户，多数情况下是不会键入符合大小写规则的内容。 123456computed: &#123; filteredNames() &#123; let filter = new RegExp(this.findName, 'i') return this.names.filter(el =&gt; el.match(filter)) &#125;&#125; 随后我们更新页面模板中的输出项，将： 12345&lt;ul&gt; &lt;li v-for=\"name in names\"&gt; &#123;&#123; name &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 调整为： 12345&lt;ul&gt; &lt;li v-for=\"name in filteredNames\"&gt; &#123;&#123; name &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 可以看到，我们每次键入任何的信息，都会展示过滤后的内容。可见我们只须键入几行代码，而不须引用其它的类库，就能顺利的实现功能需求。 我不会告诉你，这帮我省下了多少事件。如果你在使用Vue，而未合理的使用计算属性 ，赶紧来试试，定让你开心的飞起来。 WatchersVue 有着很好的抽象体系设计，不过基本上每个编程人员在使用抽象类时，都会有遇到绕不过的坎而不爽。但也正式基于此痛点，Vue 提供给我们在响应体系中更深度的操作能力，以便我们通过设置钩子来观察任何数据的改变。讲真，这实在太有用了，因为作为一个应用的开发者，大多数时候我们是对数据的变化而响应相关操作的。 Watchers(侦听器) 允许我们编写更多声明式代码。以简化我们自己编写的代码量。Vue 已在底层实现了此功能，因此我们能在 data，computed 或 props 中跟踪任何数值的改变，来举个例。 Watchers(侦听器) 在监测属性值改变时，执行特定的业务逻辑代码非常好用(我第一次是从 Chris Fritz 听到这种操作方式的，但是他说他也是从别处体验到的☺️)。多数情况下，通过检测属性的改变来执行业务逻辑，这也正是 与 计算属性不同的地方。 现在来跑一个简单的例子，感受下 watch的效果 123&lt;div id=\"app\"&gt; &lt;input type=\"number\" v-model.number=\"counter\"&gt;&lt;/input&gt;&lt;/div&gt; 12345678910111213new Vue(&#123; el: '#app', data() &#123; return &#123; counter: 0 &#125; &#125;, watch: &#123; counter() &#123; console.log('The counter has changed!') &#125; &#125;&#125;) 如上面代码所示，我们在data中设置了counter，并将此属性名称作为方法名称，在watch中配置counter，以便我们能监测设置的counter属性值，最后我们可以看到，一旦counter数值发生改变，控制台都有输出。 Transitioning State With Watchers如果监测的状态标识符很简单，那么可以使用watch(侦听器)来实现一个根据状态值改变的过度效果。以下是一个使用Vue来完成的柱状图表。随着数值的变化，watch(侦听器)将通过过度效果来更新图表。 SVG 如下面的例子一样很好使用，因为其以 数据 来构建。 点击查看DEMO 12345678910111213141516171819202122watch: &#123; selected: function(newValue, oldValue) &#123; var tweenedData = &#123;&#125; var update = function () &#123; let obj = Object.values(tweenedData); obj.pop(); this.targetVal = obj; &#125; var tweenSourceData = &#123; onUpdate: update, onUpdateScope: this &#125; for (let i = 0; i &lt; oldValue.length; i++) &#123; let key = i.toString() tweenedData[key] = oldValue[i] tweenSourceData[key] = newValue[i] &#125; TweenMax.to(tweenedData, 1, tweenSourceData) &#125;&#125; 这里干了些啥呢？ 首先我们创建了一个对象，其会通过动画库来更新。 然后这里可以看到一个update方法， 接下来创建一个对象来接收 接着创建一个for循环，将当前下编转换为字符串类型 但我们只对指定的键值执行此操作 我们也能在侦听器中使用动画来实现一个时差刻度盘。因为我时不时的会外出溜达，并且我的小伙伴也分散在不同的地方，所以需求之一就是能保证一个我们各自的当地时间都能在线，并且体现出是白天还是夜晚。 点击查看DEMO 这里我们监听 选中的属性值，根据当前时间去触发不同的方法来改变 各个区域时间，其会通过色调，饱和度，和其它过度效果来展现。在之前的实现方式中，我们是通过下拉事件，而现在是在侦听器的方法中了。 12345678910111213141516171819watch: &#123; checked() &#123; let period = this.timeVal.slice(-2), hr = this.timeVal.slice(0, this.timeVal.indexOf(':')); const dayhr = 12, rpos = 115, rneg = -118; if ((period === 'AM' &amp;&amp; hr != 12) || (period === 'PM' &amp;&amp; hr == 12)) &#123; this.spin(`$&#123;rneg - (rneg / dayhr) * hr&#125;`) this.animTime(1 - hr / dayhr, period) &#125; else &#123; this.spin(`$&#123;(rpos / dayhr) * hr&#125;`) this.animTime(hr / dayhr, period) &#125; &#125;&#125;, 关于watchers(侦听器)还有很多其它有趣的使用方式，比如： 从输入，到异步更新，再到动画，watchers(侦听器)在更新方面能做的事实在是太多了。如果你对 Vue是如何处理响应工作感到好奇， 这部分指南会十分有帮助。如果你想更加全面的了解 响应，我十分推荐 Andre Staltz’ post 和 Mike Bostock’s A Better Way to Code的响应章节部分。 总结希望通过以上各部分的讲解，有助于我们正确的使用三者，以及更有效的使用Vue来加速开发我们的应用。有报告指出，我们花费70%的时间阅读代码，30%的时间编写代码，作为个人而言，身为维护者的我，喜欢这种感觉，通过查看代码库，开启了我之前从未了解过的编写方法，并且马上了解作者在methods，computed，watchers的区别用意。","tags":[{"name":"vue","slug":"vue","permalink":"https://tangme.github.io/tags/vue/"}]},{"title":"JS-Array-常用方法","date":"2018-04-27T02:57:08.000Z","path":"2018/04/27/JS-Array-常用方法/","text":"静态方法Array.isArray(obj); 检测给定值是否为数组； 是则返回 true | 否则返回 false 123console.log(Array.isArray([]));/* true */console.log(Array.isArray(new Array(1,2)));/* true */console.log(Array.isArray(&#123;&#125;));/* false */ 对操作数组本身进行修改的方法 pop 删除并返回数组的最后一个元素 push 向末尾添加一个或多个元素，并返回新的长度 shift 删除并返回数据的第一个元素 splice 删除元素，并向数组添加元素 unshift 向开头添加一个或多个元素，并返回新的长度 reverse 颠倒数组中元素的顺序 sort 排序 fill 用指定值来填充数组 对操作数组本身 无影响 concat 连接两个或多个数组，并返回结果 join 将数组的所有元素放入一个字符串中，元素按指定的分隔符进行连接 slice 从已有的数组返回选定的元素 map 返回调用处理方法后的数组值 forEach 遍历数组所有值，并将值逐一传给回调函数 filter 返回一个新数组，新数组中为符合条件的所有值 find 返回符合条件的第一个值 findIndex 返回符合条件第一个值得下标索引 indexOf 返回指定值在数组中首次出现的位置 includes 数组是否包含指定值 every 遍历数组，检测是否所有值都符合给定的函数判断；全部符合返回true some 遍历数组，检测是否有符合给定函数的判断；有一个符合则返回true 对数组本身进行修改的方法pop 删除数组中的最后一个元素，并返回删除的元素 123456789let arr = [1,2,&apos;a&apos;,&#123;b:2&#125;];console.log(arr);/* [ 1, 2, &apos;a&apos;, &#123; b: 2 &#125; ] */console.log(arr.pop());/* &#123; b: 2 &#125; */console.log(arr);/* [ 1, 2, &apos;a&apos; ] */ push 向数组末尾添加一个或多个元素，并返回新的长度 1234567891011121314151617let arr = [1,2];let arrb = [&apos;a&apos;,&apos;b&apos;];console.log(arr);/* [ 1, 2 ] */console.log(arr.push(...arrb));/* length:4 */console.log(arr);/* [ 1, 2, &apos;a&apos;, &apos;b&apos; ] */arrb[0]=&apos;c&apos;;console.log(arr);/* [ 1, 2, &apos;a&apos;, &apos;b&apos; ] */console.log(arrb);/* [ &apos;c&apos;, &apos;b&apos; ] */ shift 删除数组中的第一个元素，并返回删除的元素 123456let arr = [&#123;a:1&#125;,2,3];console.log(arr.shift());/* &#123;a:1&#125; */console.log(arr);/* [2,3] */ unshift 向数组的头部增加一个或多个元素，并返回数组新的长度 1234567let arr = [&#123;a:1&#125;,2,3];let arrb = [&apos;c&apos;,&#123;name:&apos;dan&apos;&#125;];console.log(arr.unshift(...arrb));/* length:5 */console.log(arr);/* [ &apos;c&apos;, &#123; name: &apos;dan&apos; &#125;, &#123; a: 1 &#125;, 2, 3 ] */ splice 向数组指定位置删除指定个数元素 或 添加元素，并返回删除元素的数组 index : 操作的起始位置 howmany : 删除的个数 0:不删除 | 不传:删除至数组末尾 newItem,*,newItems : 新增的元素12345let arr = [1,2,3,4,5];/*从数组第二位新增两个元素,注:纯新增必须设置第二个参数为 0*/arr.splice(2,0,&#123;a:1&#125;,234);console.log(arr);/* [ 1, 2, &#123; a: 1 &#125;, 234, 3, 4, 5 ] */ reverse 颠倒数组的前后顺序，并返回颠倒排序后的数组 1234567let arr = [1,2,3,4,5];console.log(arr);/* [ 1, 2, 3, 4, 5 ] */arr.reverse();console.log(arr);/* [ 5, 4, 3, 2, 1 ] */ sort 对数组进行排序 | 无参时 按字符编码顺序升序排序 | 有参：如下 before 前一个元素 next 后一个元素升序条件如下 如果 before 小于 next，在排序后的数组中 before 应该出现在 next 之前，则返回一个小于 0 的值 如果 before 等于 next，返回 0 如果 before 大于 next，在排序后的数组中 before 应该出现在 next 之后，则返回一个大于 0 的值降序条件如下 如果 before 小于 next，在排序后的数组中 before 应该出现在 next 之后，则返回一个大于 0 的值 如果 before 等于 next，返回 0 如果 before 大于 next，在排序后的数组中 before 应该出现在 next 之前，则返回一个小于 0 的值 12345678910111213141516171819202122232425262728293031323334353637383940let arr = [&#123;name:&apos;a&apos;,age:23&#125;,&#123;name:&apos;g&apos;,age:32&#125;,&#123;name:&apos;d&apos;,age:2&#125;,&#123;name:&apos;z&apos;,age:99&#125;,&#123;name:&apos;j&apos;,age:13&#125;,&#123;name:&apos;e&apos;,age:78&#125;,&#123;name:&apos;p&apos;,age:34&#125;,&#123;name:&apos;e&apos;,age:33&#125;];function sortBy(attr,ascORdesc = &apos;asc&apos;)&#123; let ascORdescFlag = (ascORdesc== &apos;asc&apos;?1:-1); return function sort(before,next)&#123; before = before[attr]; next = next[attr]; if(before&lt;next)&#123; return -1*ascORdescFlag; &#125; if(before&gt;next)&#123; return 1*ascORdescFlag; &#125; return 0; &#125;;&#125;arr.sort(sortBy(&apos;age&apos;,22));console.log(arr);/*[ &#123; name: &apos;z&apos;, age: 99 &#125;, &#123; name: &apos;e&apos;, age: 78 &#125;, &#123; name: &apos;p&apos;, age: 34 &#125;, &#123; name: &apos;e&apos;, age: 33 &#125;, &#123; name: &apos;g&apos;, age: 32 &#125;, &#123; name: &apos;a&apos;, age: 23 &#125;, &#123; name: &apos;j&apos;, age: 13 &#125;, &#123; name: &apos;d&apos;, age: 2 &#125; ]*/arr.sort(sortBy(&apos;name&apos;));console.log(arr);/*[ &#123; name: &apos;a&apos;, age: 23 &#125;, &#123; name: &apos;d&apos;, age: 2 &#125;, &#123; name: &apos;e&apos;, age: 78 &#125;, &#123; name: &apos;e&apos;, age: 33 &#125;, &#123; name: &apos;g&apos;, age: 32 &#125;, &#123; name: &apos;j&apos;, age: 13 &#125;, &#123; name: &apos;p&apos;, age: 34 &#125;, &#123; name: &apos;z&apos;, age: 99 &#125; ]*/ fill 将指定的值 替换到 数组中的指定位置 value: 必填|填充的值 start: 可选|填充的起始位置 end: 可选|填充的结束位置 123456789101112131415161718let arr = [&apos;d&apos;,&apos;b&apos;,&apos;c&apos;,1,3];arr.fill(&apos;hello&apos;,3,5);console.log(arr);/* [ &apos;d&apos;, &apos;b&apos;, &apos;c&apos;, &apos;hello&apos;, &apos;hello&apos; ] */arr.fill(&apos;world&apos;,2);console.log(arr);/* [ &apos;d&apos;, &apos;b&apos;, &apos;world&apos;, &apos;world&apos;, &apos;world&apos; ] */arr.fill(&apos;hello world&apos;);console.log(arr);/* [ &apos;hello world&apos;, &apos;hello world&apos;, &apos;hello world&apos;, &apos;hello world&apos;, &apos;hello world&apos; ]*/ 对数组本身无影响的方法concat 连接两个或多个数组 123456789101112let arr = [1,&#123;age:28&#125;,3],arrb=[&apos;a&apos;,&apos;b&apos;],arrc = [];arrc = arrc.concat(arr,arrb);console.log(arrc);/* [ 1, &#123; age: 28 &#125;, 3, &apos;a&apos;, &apos;b&apos; ] */arr[0] = &apos;hello world&apos;;arr[1].age = 18;console.log(arrc);/*注意: 原数组中，引用类型的值修改会造成返回的新数组值修改 [引用的为同一地址][ 1, &#123; age: 18 &#125;, 3, &apos;a&apos;, &apos;b&apos; ] */ join 将数组中得所有元素连接成字符串 separator 连接各元素的分隔符；若不指定，默认为逗号连接 123456789101112131415let arr = [-1,&apos;a&apos;,[&apos;b&apos;,&apos;c&apos;,[&apos;d&apos;,&apos;e&apos;]],&apos;123a&apos;];console.log(arr.join());/* -1,a,b,c,d,e,123a */console.log(arr.join(&apos;&apos;));/* -1ab,c,d,e123a *//*打平嵌套数组* 注：处理后，如元素组中的元素 为String类型的数字，处理后为Number类型*/function unwind(array)&#123; return arr.join(&apos;,&apos;).split(&apos;,&apos;).map((item)=&gt;&#123;return Number(item)?Number(item):item&#125;);&#125;console.log(unwind(arr));/* [ -1, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, 123 ] */ slice 返回数组中指定的元素 start | [起始下标] -1 为数组最后的元素 end | [结束下标] 1234567let arr = [1,&apos;b&apos;,&#123;c:&apos;hello&apos;&#125;,&apos;d&apos;];let arrb = arr.slice(-1),arrc = arr.slice();console.log(arrb);/* [ &apos;d&apos; ] */console.log(arrc);/* [ 1, &apos;b&apos;, &#123; c: &apos;hello&apos; &#125;, &apos;d&apos; ] */ map 返回一个新数组,新元素为 原元素调用函数处理后的值 currentValue： 当前值[原数组] | 必须 index： 当前值的下标索引 | 可选 arr： 原数组对象 | 可选 123456789let arr = [1,3,&apos;4&apos;,&apos;b&apos;,&#123;c:&apos;hello&apos;&#125;];let arrb = arr.map(function(item)&#123; return item*2;&#125;);console.log(arr);/* [ 1, 3, &apos;4&apos;, &apos;b&apos;, &#123; c: &apos;hello&apos; &#125; ] */console.log(arrb);/* [ 2, 6, 8, NaN, NaN ] */ forEach 遍历数组的每个元素，并将元素传递给回调函数 currentValue： 当前值[原数组] | 必须 index： 当前值的下标索引 | 可选 arr： 原数组对象 | 可选 1234567891011121314151617/**数组去重*此方法仅可用于基础类型的值 去重，引用类型无法去除*/function uniq(array)&#123; let returnArr = [],tmpMap = &#123;&#125;; array.forEach((item)=&gt;&#123; if(!tmpMap[item])&#123; returnArr.push(item); tmpMap[item] = 1; &#125; &#125;); return returnArr;&#125;let testArr = [1,1,2,2,2,3,3,3,3,&apos;a&apos;,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&#123;d:&apos;123&apos;&#125;,&#123;d:&apos;456&apos;&#125;];console.log(uniq(testArr));/* [ 1, 2, 3, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &#123; d: &apos;123&apos; &#125; ] */ filter 返回一个新数组，新数组中的元素为符合判断条件的元素 currentValue： 当前值[原数组] | 必须 index： 当前值的下标索引 | 可选 arr： 原数组对象 | 可选 123456789/* 数组去重 *此方法仅可用于基础类型的值 去重，引用类型无法去除*/let testArr = [1,1,2,2,2,3,3,3,3,&apos;a&apos;,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];let reArr = testArr.filter((item,i,arr)=&gt;&#123; return arr.indexOf(item)===i;&#125;);console.log(reArr);/* [ 1, 2, 3, &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ] */ find 返回符合条件的 第一个值 currentValue： 当前值[原数组] | 必须 index： 当前值的下标索引 | 可选 arr： 原数组对象 | 可选 123456let testArr = [&#123;age:11&#125;,&#123;age:22&#125;,&#123;age:33&#125;];let reArr = testArr.find((item,i,arr)=&gt;&#123; return item.age&gt;15;&#125;);console.log(reArr);/* &#123; age: 22 &#125; */ findIndex 返回符合条件的 第一个值的下标索引 currentValue： 当前值[原数组] | 必须 index： 当前值的下标索引 | 可选 arr： 原数组对象 | 可选 123456let testArr = [&#123;age:11&#125;,&#123;age:22&#125;,&#123;age:33&#125;];let reArr = testArr.findIndex((item,i,arr)=&gt;&#123; return item.age&gt;15;&#125;);console.log(reArr);/* 1 */ indexOf 返回指定元素值的第一个下标索引 item | 待检索的值 start | 检索的起始位置 123456789/* 数组去重 *此方法仅可用于基础类型的值 去重，引用类型无法去除*/let testArr = [1,1,2,2,2,3,3,3,3,&apos;a&apos;,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];let reArr = testArr.filter((item,i,arr)=&gt;&#123; return arr.indexOf(item)===i;&#125;);console.log(reArr);/* [ 1, 2, 3, &apos;a&apos;, &apos;b&apos;, &apos;c&apos; ] */ lastIndexOf 返回指定元素值的第一个下标索引 item | 待检索的值 123let testArr = [1,1,2,2,2,3,3,3,3,&apos;a&apos;,&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];console.log(testArr.lastIndexOf(&apos;a&apos;));/* 10 */ includes 检测数组中是否包含指定元素，有则true | 否则false item | 待检测的值 start | 检索的起始位置 123let testArr = [11,22,33];console.log(testArr.includes(22));/* true */ every 检测是否数组中的元素都符合指定的条件，都符合则返回true | 一旦有一个不符合返回 false currentValue： 当前值[原数组] | 必须 index： 当前值的下标索引 | 可选 arr： 原数组对象 | 可选 123456let testArr = [&#123;age:11&#125;,&#123;age:22&#125;,&#123;age:33&#125;];let reArr = testArr.every((item,i,arr)=&gt;&#123; return item.age&gt;15;&#125;);console.log(reArr);/* false */ some 检测数组中是否有一个满足条件的元素，只要有一个则返回true | 一个都没有则返回 false currentValue： 当前值[原数组] | 必须 index： 当前值的下标索引 | 可选 arr： 原数组对象 | 可选 123456let testArr = [&#123;age:11&#125;,&#123;age:22&#125;,&#123;age:33&#125;];let reArr = testArr.some((item,i,arr)=&gt;&#123; return item.age&gt;15;&#125;);console.log(reArr);/* true */ reduce 将数组中的每个值从左到右开始缩减，经函数处理后，最终返回一个值 function total 初始值, 或者计算结束后的返回值 | 必须 currentValue： 当前值[原数组] | 必须 index： 当前值的下标索引 | 可选 arr： 原数组对象 | 可选 可选。传递给函数的初始值 1234567/*打平嵌套数组* 使用条件仅为 待打平的数组为 二维数组*/let testArr = [1,[&apos;a&apos;,&apos;c&apos;],3];console.log(testArr.reduce((r,item)=&gt;r.concat(item),[]));/* [ 1, &apos;a&apos;, &apos;c&apos;, 3 ] *//* 注：不提供默认值时：初始的默认值为 首位元素的值*/ reduceRight 将数组中的每个值从右到左开始缩减，经函数处理后，最终返回一个值 function total 初始值, 或者计算结束后的返回值 | 必须 currentValue： 当前值[原数组] | 必须 index： 当前值的下标索引 | 可选 arr： 原数组对象 | 可选 可选。传递给函数的初始值 123456let testArr = [1,2,3,4,5,6];console.log(testArr.reduce((total,item)=&gt;&#123; return total-item;&#125;));/* 注：不提供默认值时：初始的默认值为 末位元素的值*//* -19 */","tags":[{"name":"javascript","slug":"javascript","permalink":"https://tangme.github.io/tags/javascript/"}]},{"title":"JS-总结","date":"2018-04-27T02:53:39.000Z","path":"2018/04/27/JS-总结/","text":"JS-Array-常用方法","tags":[{"name":"javascript","slug":"javascript","permalink":"https://tangme.github.io/tags/javascript/"}]},{"title":"CSSLint-目录","date":"2018-04-25T08:19:10.000Z","path":"2018/04/25/CSSLint-目录/","text":"csslint 语法建议规则 规则 根据字母升序排列 原址 原址 原址 原址 原址 原址 原址 原址 原址 原址 原址 原址 原址 原址 原址 原址 原址 原址 原址 原址 原址 原址 原址 原址 原址 原址 原址 原址 原址 原址 原址","tags":[{"name":"CSS","slug":"CSS","permalink":"https://tangme.github.io/tags/CSS/"},{"name":"目录","slug":"目录","permalink":"https://tangme.github.io/tags/目录/"}]}]